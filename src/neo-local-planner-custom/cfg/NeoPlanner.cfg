#!/usr/bin/env python

PACKAGE = 'neo_local_planner'

from math import pi

from dynamic_reconfigure.parameter_generator_catkin import ParameterGenerator, double_t, int_t, bool_t, str_t

gen = ParameterGenerator()

# gen.add("inscribed_radius", double_t, 0, "The radius of the inscribed circle of the robot", 1, 0)
# gen.add("circumscribed_radius", double_t, 0, "The radius of the circumscribed circle of the robot", 1, 0)

gen.add("acc_lim_x", double_t, 0, "The acceleration limit of the robot in the x direction", 0.3, -20, 20.0)
gen.add("acc_lim_theta", double_t, 0, "The acceleration limit of the robot in the theta direction", 1.5, -20, 20.0)
gen.add("stop_acc", double_t, 0, "The acceleration limit of the robot in the x direction when stop", 0.3, -20, 20.0)
gen.add("emergency_acc_lim_theta",  double_t, 0, "Acc when emgergency", 2, -20, 20)

gen.add("max_vel_x", double_t, 0, "The maximum x velocity for the robot in m/s", 1.2, -20, 20.0)
gen.add("min_vel_x", double_t, 0, "The minimum x velocity for the robot in m/s", 0.0, -20, 20.0)

gen.add("max_rot_vel", double_t, 0, "The absolute value of the maximum rotational velocity for the robot in rad/s",  0.7, -20, 20.0)
gen.add("min_rot_vel", double_t, 0, "The absolute value of the minimum rotational velocity for the robot in rad/s", 0.1, -20.0, 20.0)

gen.add("max_vel_trans", double_t, 0, "The absolute value of the maximum rotational velocity for the robot in rad/s",  1.2, -20, 20.0)
gen.add("min_vel_trans", double_t, 0, "The absolute value of the minimum rotational velocity for the robot in rad/s", 0.1, -20.0, 20.0)

gen.add("rot_stopped_vel", double_t, 0, "The absolute value of the maximum rotational velocity for the robot in rad/s",  0.05, -20, 20.0)
gen.add("trans_stopped_vel", double_t, 0, "The absolute value of the maximum rotational velocity for the robot in rad/s",  0.05, -20, 20.0)
gen.add("yaw_goal_tolerance", double_t, 0, "The tolerance in radians for the controller in yaw/rotation when achieving its goal",  0.1, -20, 20.0)
gen.add("xy_goal_tolerance", double_t, 0, "The tolerance in meters for the controller in the x & y distance when achieving a goal", 0.05, -20.0, 20.0)
gen.add("differential_drive", bool_t, 0, "If robot has differential drive, holonomic otherwise", True)
gen.add("constrain_final", bool_t, 0, "The absolute value of the maximum rotational velocity for the robot in rad/s",  False)
gen.add("goal_tune_time", double_t, 0, "How long to fine tune for goal position after reaching tolerance limits [s]", 0.5, -20.0, 20.0)

gen.add("lookahead_time", double_t, 0, "How far to predict control pose into the future based on latest odometry [s]",  0.5, -20, 20.0)
gen.add("lookahead_dist", double_t, 0, "How far to look ahead when computing path orientation [m]", 0.3, -20.0, 20.0)

gen.add("start_yaw_error_normal", double_t, 0, "Threshold yaw error below which we consider to start moving [rad]", 0.1, -20, 20)
gen.add("start_yaw_error_when_safety", double_t, 0, "Threshold yaw error below which we consider to start moving if have safety [rad]", 0.1, -20, 20)
gen.add("pos_x_gain", double_t, 0, "Gain when adjusting final x position for goal [1/s]", 1, -20, 20)

gen.add("pos_y_gain", double_t, 0, "Gain for lane keeping based on y error (differential only) [rad/s^2]", 1, -20, 20)
gen.add("pos_y_yaw_gain", double_t, 0, "Gain for lane keeping based on y error (differential only) [rad/s^2]", 1, -20, 20)
gen.add("yaw_gain", double_t, 0, "Gain for lane keeping based on yaw error (differential only) [1/s]", 2, -20, 20)

gen.add("static_yaw_gain", double_t, 0, "Gain for adjusting yaw when not translating, or in case of holonomic drive [1/s]", 3, -20, 20)
gen.add("cost_x_gain", double_t, 0, "Gain for x cost avoidance", 0.1, -20, 20)
gen.add("cost_y_gain", double_t, 0, "TGain for y cost avoidance", 0.1, -20, 20)

gen.add("cost_y_yaw_gain", double_t, 0, "Gain for y cost avoidance (differential only)", 0.2, -20, 20)
gen.add("cost_y_lookahead_dist", double_t, 0, "The number of samples to use when exploring the theta velocity space", 0.3, -20, 20)

gen.add("cost_y_lookahead_time", double_t, 0, "How far ahead to compute y cost gradient (dynamic offset) [s]", 1.5, -20, 20)

gen.add("cost_yaw_gain", double_t, 0, "Gain for yaw cost avoidance", 2, -20, 20)

gen.add("low_pass_gain", double_t, 0, "Gain for final control low pass filter", 0.2, -20, 20)

gen.add("max_cost", double_t, 0, "Max cost to allow, above we slow down to min_trans_vel or even stop", 0.95, -20, 20)

gen.add("max_curve_vel", double_t, 0, "Max velocity based on curvature [rad/s]", 0.3, -20, 20)
gen.add("max_goal_dist", double_t, 0, "Max distance to goal when looking for it [m]", 0.6, -20, 20)

gen.add("max_backup_dist", double_t, 0, "Max distance allowable for backing up (zero = unlimited) [m]",  0.1, -20, 20)

gen.add("min_stop_dist", double_t, 0, "Minimal distance to obstacle for stopping [m]", 0.3, -20, 20)

gen.add("emergency_acc_lim_x",  double_t, 0, "Acc when emgergency", 1.5, -20, 20)

gen.add("enable_software_stop", bool_t, 0, "Footprint based collision avoidance", False)
gen.add("allow_reversing", bool_t, 0, "Robot with safety sensors in the rear can be set to reverse", False)

gen.add("vel_max_safety_field_0", double_t, 0, "Vel max in safety field 0", 0, -20, 20)

gen.add("vel_max_safety_field_1", double_t, 0, "Vel max in safety field 1", 0, -20, 20)

gen.add("vel_max_safety_field_2",  double_t, 0, "Vel max in safety field 2", 0.3, -20, 20)
gen.add("vel_max_safety_field_3", double_t, 0, "Vel max in safety field 3", 0.5, -20, 20)

gen.add("max_time_check_stop_by_safety", double_t, 0, "Time delay after get safety", 1, -20, 20)

gen.add("print_state",  bool_t, 0, "Print current state or not", False)
gen.add("publish_safety",  bool_t, 0, "publish safety or not", True)
gen.add("slow_speed", bool_t, 0, "Robot run slow when near slow point", False)
gen.add("stop_center_qr", bool_t, 0, "Allow robot succeed goal when reach center qr", True)

gen.add("dist_stop_agv_to_qr_code", double_t, 0, "Dist from agv to center qr code to stop robot", 0.02, -20, 20)

exit(gen.generate(PACKAGE, "neo_local_planner", "NeoPlanner"))